# TODO: Object dependencies must be manually specified in the source files. A more automatic solution would be nice

# recursive wildcard 
rwildcard = $(foreach d,$(wildcard $1*),$(call rwildcard,$d/,$2) $(filter $(subst *,%,$2),$d))
# remove duplicates from list
uniq      = $(if $1,$(firstword $1) $(call uniq,$(filter-out $(firstword $1),$1)))

COMPILE_COMMANDS = compile_commands.json
BIN_DIR          = out
INCLUDE_DIR      = include
OBJ_DIR          = src
TEST_DIR         = test
CMD_DIR          = cmd

OBJ_OUT_DIR  = $(BIN_DIR)/obj
TEST_OUT_DIR = $(BIN_DIR)/test
CMD_OUT_DIR  = $(BIN_DIR)/cmd

OBJ_SRC  = $(call rwildcard,$(OBJ_DIR),*.c)
TEST_SRC = $(call rwildcard,$(TEST_DIR),*.c)
CMD_SRC  = $(call rwildcard,$(CMD_DIR),*.c)

OBJ_OUT  = $(patsubst $(OBJ_DIR)/%,  $(OBJ_OUT_DIR)/%, $(OBJ_SRC:.c=.o))
TEST_OUT = $(patsubst $(TEST_DIR)/%, $(TEST_OUT_DIR)/%, $(TEST_SRC:.c=))
CMD_OUT  = $(patsubst $(CMD_DIR)/%, $(CMD_OUT_DIR)/%, $(CMD_SRC:.c=))

# $1: source file
# $2: output file
# awk: for each line starting with '// link', print each following argument, separated by whitespace, prepended with the obj out dir
define LINK_OBJECTS
DEPS := $(shell awk '$$0 ~ /^\/\/ *link/ { for (i = 3; i <= NF; i++) print "$$(OBJ_OUT_DIR)/" $$i  }' $(1))
$(2): $$(DEPS)
endef

$(foreach test,$(TEST_SRC), $(eval $(call \
	LINK_OBJECTS,\
	$(test),\
	$(patsubst $(TEST_DIR)/%, $(TEST_OUT_DIR)/%, $(test:.c=)))))

$(foreach cmd,$(CMD_SRC), $(eval $(call \
	LINK_OBJECTS,\
	$(cmd),\
	$(patsubst $(CMD_DIR)/%, $(CMD_OUT_DIR)/%, $(cmd:.c=)))))

# This target exists mostly as a hack to make incremental builds that only run tests where the inputs changed
TEST_RESULT = $(TEST_OUT:=.log)

MMD_FILES = $(call rwildcard,$(BIN_DIR),*.d)
DIRECTORIES = $(call uniq,$(dir $(OBJ_OUT) $(TEST_OUT) $(CMD_OUT)))

CFLAGS += -std=c1x -pedantic -Wall -Wextra -D_FILE_OFFSET_BITS=64 -D_GNU_SOURCE -I$(INCLUDE_DIR) -rdynamic -O0 -g -MMD -MF $@.d

.PHONY: all
all: $(OBJ_OUT) $(TEST_OUT) $(CMD_OUT)

$(DIRECTORIES):
	@mkdir -p $(DIRECTORIES)

$(OBJ_OUT_DIR)%.o: $(OBJ_DIR)%.c | $(DIRECTORIES)
	$(CC) $(CFLAGS) -c -o $@ $<

$(TEST_OUT_DIR)%: $(TEST_DIR)%.c | $(DIRECTORIES)
	$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

$(CMD_OUT_DIR)%: $(CMD_DIR)%.c | $(DIRECTORIES)
	$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

.PHONY: clean
clean:
	rm -f $(OBJ_OUT) $(TEST_OUT) $(CMD_OUT) $(MMD_FILES) $(TEST_RESULT) $(COMPILE_COMMANDS)

$(COMPILE_COMMANDS): Makefile $(OBJ_OUT) $(TEST_OUT) $(CMD_OUT)
	bear -- make all -B

# Run all tests
.PHONY: test
test: $(TEST_OUT)
	@for test in $(TEST_OUT); do \
		echo "====== $$test ======"; \
		$$test; \
	done

# Run tests if input changed
$(TEST_OUT_DIR)%.log: $(TEST_OUT_DIR)%
	@(set -o pipefail;         \
		echo "====== $< ======"; \
		./$< |& tee $@;          \
		)

# Run tests where input changed
.PHONY: incremental-test
incremental-test: $(TEST_RESULT)

# Include object dependencies generated by -MMD -MF $@.d
-include $(MMD_FILES)
